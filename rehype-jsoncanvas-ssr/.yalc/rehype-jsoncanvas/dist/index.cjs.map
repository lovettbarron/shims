{"version":3,"file":"index.cjs","sources":["../node_modules/web-namespaces/index.js","../node_modules/hast-util-from-dom/lib/index.js","../node_modules/hast-util-from-html-isomorphic/lib/browser.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/index.js","../src/options.ts","../src/embed.ts","../src/jsoncanvas.ts","../node_modules/@trbn/jsoncanvas/dist/index.mjs","../src/plugin.ts","../node_modules/unist-util-visit/lib/index.js"],"sourcesContent":["/**\n * Map of web namespaces.\n *\n * @type {Record<string, string>}\n */\nexport const webNamespaces = {\n  html: 'http://www.w3.org/1999/xhtml',\n  mathml: 'http://www.w3.org/1998/Math/MathML',\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n}\n","/**\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Doctype} HastDoctype\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n */\n\n/**\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNodes} hastNode\n *   Corresponding hast node.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed (optional).\n */\n\nimport {h, s} from 'hastscript'\nimport {webNamespaces} from 'web-namespaces'\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   Equivalent hast node.\n */\nexport function fromDom(tree, options) {\n  return transform(tree, options || {}) || {type: 'root', children: []}\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options)\n  if (transformed && options.afterTransform)\n    options.afterTransform(node, transformed)\n  return transformed\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */: {\n      const domNode = /** @type {Element} */ (node)\n      return element(domNode, options)\n    }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */: {\n      const domNode = /** @type {Text} */ (node)\n      return text(domNode)\n    }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */: {\n      const domNode = /** @type {Comment} */ (node)\n      return comment(domNode)\n    }\n\n    case 9 /* Document */: {\n      const domNode = /** @type {Document} */ (node)\n      return root(domNode, options)\n    }\n\n    case 10 /* Document type */: {\n      return doctype()\n    }\n\n    case 11 /* Document fragment */: {\n      const domNode = /** @type {DocumentFragment} */ (node)\n      return root(domNode, options)\n    }\n\n    default: {\n      return undefined\n    }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {type: 'root', children: all(node, options)}\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {type: 'text', value: node.nodeValue || ''}\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {type: 'comment', value: node.nodeValue || ''}\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI\n  const fn = space === webNamespaces.svg ? s : h\n  const tagName =\n    space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\n  /** @type {DocumentFragment | Element} */\n  const content =\n    // @ts-expect-error: DOM types are wrong, content can exist.\n    space === webNamespaces.html && tagName === 'template' ? node.content : node\n  const attributes = node.getAttributeNames()\n  /** @type {Record<string, string>} */\n  const props = {}\n  let index = -1\n\n  while (++index < attributes.length) {\n    props[attributes[index]] = node.getAttribute(attributes[index]) || ''\n  }\n\n  return fn(tagName, props, all(content, options))\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastRootContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes\n  /** @type {Array<HastRootContent>} */\n  const children = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options)\n\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child)\n    }\n  }\n\n  return children\n}\n","/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef {typeof import('./index.js').fromHtmlIsomorphic} FromHtmlIsomorphic\n */\n\nimport {fromDom} from 'hast-util-from-dom'\n\nconst parser = new DOMParser()\n\n/** @type {FromHtmlIsomorphic} */\nexport function fromHtmlIsomorphic(value, options) {\n  const node = options?.fragment\n    ? parseFragment(value)\n    : parser.parseFromString(value, 'text/html')\n\n  return /** @type {Root} */ (fromDom(node))\n}\n\n/**\n * Parse as a fragment.\n *\n * @param {string} value\n * @returns {DocumentFragment}\n */\nfunction parseFragment(value) {\n  const template = document.createElement('template')\n  template.innerHTML = value\n  return template.content\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn’t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * Options for the jsoncanvas\n */\nexport interface Options {\n  /**\n   * Open links in a new tab\n   *\n   * Defaults to true\n   */\n  openEmbededInNewTab: boolean;\n\n  /**\n   * Render mode. Determines the canvas output mode\n   *\n   * Defaults to canvas\n   */\n  renderMode: \"svg\" | \"image\" | \"canvas\";\n\n  /**\n   * Canvas Buffer\n   *\n   * Defaults to 30\n   */\n  canvasBuffer: number;\n\n  /**\n   * Canvas node stroke width\n   *\n   * Defaults to 3\n   */\n  nodeStrokeWidth: number;\n\n  /**\n   * Canvas line stroke width\n   *\n   * Defaults to 5\n   */\n  lineStrokeWidth: number;\n}\n\n/**\n * Applies default values for any unspecified options\n */\nexport function applyDefaults(config: Partial<Options> = {}): Options {\n  return {\n    openEmbededInNewTab:\n      config.openEmbededInNewTab === undefined\n        ? true\n        : config.openEmbededInNewTab,\n    renderMode: config.renderMode === undefined ? \"canvas\" : config.renderMode,\n    canvasBuffer: config.canvasBuffer === undefined ? 30 : config.canvasBuffer,\n    nodeStrokeWidth:\n      config.nodeStrokeWidth === undefined ? 3 : config.nodeStrokeWidth,\n    lineStrokeWidth:\n      config.lineStrokeWidth === undefined ? 5 : config.lineStrokeWidth,\n  };\n}\n","import { s } from \"hastscript\";\nimport { Element } from \"hast\";\n\nimport { fromMarkdown } from \"mdast-util-from-markdown\";\nimport { toHast } from \"mdast-util-to-hast\";\n\nimport { GenericNode } from \"@trbn/jsoncanvas\";\n// import { applyDefaults, Options } from \"./options\";\n\nconst imagesLoaded = [] as Array<any>;\n\nexport function checkImagesLoaded(callback: Function) {\n  let allLoaded = imagesLoaded.every((el) => el.complete);\n  console.group(\"Images loading\", imagesLoaded, allLoaded);\n  if (imagesLoaded.length < 1) return callback();\n  //   return callback();\n  if (allLoaded) callback();\n  else checkImagesLoaded(callback);\n}\n\n// This renders out the images\nexport async function drawEmbedded(svg: Element, node: GenericNode | any) {\n  if (node.type === \"file\" && svg) {\n    if (node.file.match(/\\.(jpg|jpeg|png|gif)$/i)) {\n      const image = s(\"image\", {\n        x: node.x,\n        y: node.y,\n        width: node.width,\n        height: node.height,\n        \"xlink:href\": node.file,\n      });\n\n      svg.children.push(image);\n    }\n  }\n}\n\n// This renders out the images\nexport async function drawMarkdownEmbed(svg: Element, node: GenericNode | any) {\n  if (node.type === \"file\" && svg) {\n    if (node.file.match(/\\.(md|mdx)$/i)) {\n      const resp = await fetch(node.file);\n      const mdFile = await resp.text();\n\n      const mdast = fromMarkdown(mdFile);\n      const hast = toHast(mdast);\n\n      // Ref: https://stackoverflow.com/questions/45518545/svg-foreignobject-not-showing-on-any-browser-why\n      const embed = s(\"foreignObject\", {\n        x: node.x,\n        y: node.y,\n        width: node.width,\n        height: node.height,\n      });\n      embed.children.push(hast as Element); // If this breaks, this is probably the spot it breaks\n\n      svg.children.push(embed);\n    }\n  }\n}\n","import { s } from \"hastscript\";\nimport { Element } from \"hast\";\n\nimport { JSONCanvas, Edge, GenericNode } from \"@trbn/jsoncanvas\";\n\nimport { applyDefaults, Options } from \"./options\";\n\nimport { drawEmbedded, drawMarkdownEmbed, checkImagesLoaded } from \"./embed\";\n\nfunction calculateMinimumCanvasSize(canvas: JSONCanvas) {\n  let minX = Infinity,\n    minY = Infinity,\n    maxX = -Infinity,\n    maxY = -Infinity;\n\n  canvas.getNodes().forEach((node) => {\n    minX = Math.min(minX, node.x);\n    minY = Math.min(minY, node.y);\n    maxX = Math.max(maxX, node.x + node.width);\n    maxY = Math.max(maxY, node.y + node.height);\n  });\n\n  const canvasWidth = maxX - minX;\n  const canvasHeight = maxY - minY;\n\n  return { canvasWidth, canvasHeight, offsetX: -minX, offsetY: -minY };\n}\n\nexport function validate(jsonCanvasData: JSONCanvas) {\n  // Use the typescript lib to vlaidate?\n  console.log(\"Validate!\", jsonCanvasData);\n  return true;\n}\n\nexport function render(\n  jsc: JSONCanvas,\n  config?: Partial<Options>\n): String | any | null {\n  const options = applyDefaults(config);\n\n  const { canvasWidth, canvasHeight, offsetX, offsetY } =\n    calculateMinimumCanvasSize(jsc);\n\n  // Init Canvas objects\n  const svg = initRender(canvasWidth + offsetX, canvasHeight + offsetY);\n\n  if (svg === null) return null;\n\n  // Draw nodes\n  jsc.getNodes().forEach((node) => {\n    drawNode(svg, node, options);\n  });\n\n  // Draw Edges\n  jsc.getEdges().forEach((edge) => {\n    const fromNode = jsc.getNodes().find((node) => node.id === edge.fromNode);\n    const toNode = jsc.getNodes().find((node) => node.id === edge.toNode);\n    if (toNode !== undefined && fromNode !== undefined)\n      drawEdge(svg, toNode, fromNode, edge, options);\n  });\n\n  return checkImagesLoaded(() => renderToBuffer(svg));\n}\n\nfunction renderToBuffer(svg: Element, config?: Partial<Options>) {\n  const options = applyDefaults(config);\n  console.log(\"Rendering\", svg, options);\n  return null;\n}\n\nfunction initRender(\n  width: number,\n  height: number,\n  config?: Partial<Options>\n): Element {\n  const options = applyDefaults(config);\n  console.log(options);\n  const BASE_SVG_PROPS = {\n    version: \"1.1\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    \"stroke-width\": options.lineStrokeWidth,\n    \"fill-rule\": \"evenodd\",\n    fill: \"currentColor\",\n    stroke: \"currentColor\",\n  };\n\n  const props = {\n    ...BASE_SVG_PROPS,\n    width: width as number,\n    height: height as number,\n    viewBox: `0 0 ${width} ${height}`,\n  };\n\n  const svg = s(\"svg\", props);\n  svg.properties;\n  return svg;\n}\n\nasync function drawNode(\n  svg: Element,\n  node: GenericNode | any,\n  config?: Partial<Options>\n) {\n  const options = applyDefaults(config);\n\n  let fillStyle = \"rgba(255, 255, 255, .5)\";\n  let strokeStyle = \"rgba(0,0,0,1)\";\n\n  if (node.color === \"1\") {\n    fillStyle = \"rgba(255, 0, 0, .5)\";\n    strokeStyle = \"rgba(255,0,0,1)\";\n  } else if (node.color === \"2\") {\n    fillStyle = \"rgba(255, 100, 0, .5)\";\n    strokeStyle = \"rgba(255,100,0,1)\";\n  } else if (node.color === \"3\") {\n    fillStyle = \"rgba(255, 255, 0, .5)\";\n    strokeStyle = \"rgba(255,255,0,1)\";\n  } else if (node.color === \"4\") {\n    fillStyle = \"rgba(0, 255, 100, .5)\";\n    strokeStyle = \"rgba(0,100,0,1)\";\n  } else if (node.color === \"5\") {\n    fillStyle = \"rgba(0, 255, 255, .5)\";\n    strokeStyle = \"rgba(0,255,255,1)\";\n  } else if (node.color === \"6\") {\n    fillStyle = \"rgba(100, 10, 100, .5)\";\n    strokeStyle = \"rgba(100,10,100,1)\";\n  }\n\n  const group = s(\"g\");\n\n  const rect = s(\"rect\", {\n    x: node.x + <number>svg.properties!.width / 2,\n    y: node.y + <number>svg.properties!.height / 2,\n    width: node.width,\n    height: node.height,\n    rx: 5,\n    ry: 5,\n    stroke: strokeStyle,\n    fill: fillStyle,\n    \"stroke-width\": options.lineStrokeWidth,\n  });\n\n  group.children.push(rect);\n\n  drawEmbedded(svg, node);\n  drawMarkdownEmbed(svg, node);\n\n  // ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\n  if (node.label) {\n    // ctx.fillText(\n    //   node.label,\n    //   node.x + 5 + canvas.width / 2,\n    //   node.y + 20 + canvas.height / 2\n    // );\n  }\n\n  if (node.type === \"text\" && node.text) {\n    // ctx.fillText(\n    //   node.text,\n    //   node.x + 5 + canvas.width / 2,\n    //   node.y + 40 + canvas.height / 2\n    // );\n  }\n\n  svg.children.push(group);\n}\n\nfunction drawEdge(\n  svg: Element,\n  toNode: GenericNode,\n  fromNode: GenericNode,\n  edge: Edge | any,\n  config?: Partial<Options>\n) {\n  const options = applyDefaults(config);\n  if (svg === null || svg == undefined) return;\n\n  const cWidth = <number>svg.properties.width || (1 as number);\n  const cHeight = <number>svg.properties.height || (1 as number);\n\n  if (fromNode && toNode) {\n    let startX =\n      fromNode.x +\n      (edge.fromSide == \"top\" || edge.fromSide == \"bottom\"\n        ? fromNode.width / 2\n        : fromNode.width) +\n      cWidth / 2;\n    let startY = fromNode.y + fromNode.height / 2 + cHeight / 2;\n    let endX =\n      toNode.x +\n      (edge.toSide == \"top\" || edge.toSide == \"bottom\"\n        ? toNode.width / 2\n        : toNode.width) +\n      cWidth / 2;\n    let endY = toNode.y + toNode.height / 2 + cHeight / 2;\n\n    if (edge.fromSide === \"left\") {\n      startX = fromNode.x + cWidth / 2;\n    } else if (edge.fromSide === \"top\") {\n      startY = fromNode.y + cHeight / 2;\n    } else if (edge.fromSide === \"bottom\") {\n      startY = fromNode.y + fromNode.height + cHeight / 2;\n    }\n\n    if (edge.toSide === \"right\") {\n      endX = toNode.x + toNode.width + cWidth / 2;\n    } else if (edge.toSide === \"top\") {\n      endY = toNode.y + cHeight / 2;\n    } else if (edge.toSide === \"bottom\") {\n      endY = toNode.y + toNode.height + cHeight / 2;\n    } else if (edge.toSide === \"left\") {\n      endX = toNode.x + cWidth / 2;\n    }\n\n    // Change the control point logic based on fromSide/toSide\n    const cp1 = {\n      x: startX,\n      y: endY,\n    };\n\n    const cp2 = {\n      x: endX,\n      y: startY,\n    };\n\n    const line = s(\"path\", {\n      d: `M ${startX} ${startY} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${endX} ${endY}`,\n      stroke: \"black\",\n      \"stroke-width\": options.lineStrokeWidth,\n      fill: \"none\",\n    });\n    svg.children.push(line);\n  }\n}\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass JSONCanvas {\n  constructor(nodes, edges) {\n    __publicField(this, \"nodes\", []);\n    __publicField(this, \"edges\", []);\n    if (nodes) {\n      this.nodes = nodes;\n    }\n    if (edges) {\n      this.edges = edges;\n    }\n  }\n  addNode(node) {\n    if (this.nodes.find((n) => n.id === node.id)) {\n      throw new Error(\"A node with the same ID already exists in this.nodes\");\n    }\n    this.nodes.push(node);\n  }\n  addEdge(edge) {\n    if (this.edges.find((e) => e.id === edge.id)) {\n      throw new Error(\"An edge with the same ID already exists in this.edges\");\n    }\n    this.edges.push(edge);\n  }\n  getNode(id) {\n    return this.nodes.find((n) => n.id === id);\n  }\n  getEdge(id) {\n    return this.edges.find((e) => e.id === id);\n  }\n  getNodes() {\n    return this.nodes;\n  }\n  getEdges() {\n    return this.edges;\n  }\n  removeNode(id) {\n    this.nodes = this.nodes.filter((n) => n.id !== id);\n    this.edges = this.edges.filter((e) => e.fromNode !== id && e.toNode !== id);\n  }\n  removeEdge(id) {\n    this.edges = this.edges.filter((e) => e.id !== id);\n  }\n  toString() {\n    return JSON.stringify({\n      nodes: this.nodes,\n      edges: this.edges\n    });\n  }\n  static fromString(json) {\n    const obj = JSON.parse(json);\n    return new JSONCanvas(obj.nodes, obj.edges);\n  }\n}\n\nexport { JSONCanvas, JSONCanvas as default };\n","import type { Plugin } from \"unified\";\nimport type { Element, ElementContent, Root } from \"hast\";\nimport { fromHtmlIsomorphic } from \"hast-util-from-html-isomorphic\";\nimport { visit } from \"unist-util-visit\";\nimport fs from \"fs\";\nimport { validate, render } from \"./jsoncanvas\";\nimport JSONCanvas from \"@trbn/jsoncanvas\";\n\n/*\n\nLet's think this through.\nI need to fetch the relevant embedded .canvas elements, and parse across two different ways of embedding, ![](file.canvas) and [[file.canvas]]\n\nThen I need to generate a canvas node, and populate it with the relevent objects per the jsoncanvas spec\n\nThen I need to pass this populated canvas back to rehype to be placed into the rendered html stream\n\nCore Assumptions:\n- Assume serverside, pga markdown\n- Assume a canvas fallback incase of old browser\n- Assume a need for arbitrary sized canvas\n- Assume a fallback for improperly formatted canvas\n\nThings decide:\n- Navigable/zoomable?\n- Themeable? > Probably want a css module that can be overridden in config\n\n*/\n\nexport const rehypeJsonCanvas: Plugin<[], Root> = () => {\n  return async (tree) => {\n    const nodesToReplace = [] as Array<Element>;\n\n    // Iterate over the markdown file as tree\n    visit(tree, \"element\", (node, index) => {\n      console.log(node, index);\n\n      // only match image embeds\n      if (node.tagName !== \"img\" || index === undefined) {\n        return;\n      }\n      console.log(\"Adding\", node);\n      nodesToReplace.push(node);\n      // index = index += 1;\n    });\n\n    for (const node of nodesToReplace) {\n      const canvasPath = node.properties.src as string;\n      console.log(\"Detected\", canvasPath);\n      let canvasMarkdown = await getCanvasFromEmbed(canvasPath);\n\n      console.log(\"Got markdown\", canvasMarkdown);\n      const jsonCanvasFromString = JSONCanvas.fromString(canvasMarkdown);\n\n      let canvas;\n\n      if (validate(jsonCanvasFromString)) {\n        canvas = render(jsonCanvasFromString, {});\n      } else {\n        canvas = \"<div>Not a properly formatted JsonCanvas</div>\";\n      }\n\n      console.log(canvas);\n\n      const canvasHast = fromHtmlIsomorphic(\n        `<img alt='' src='${canvas}' style='width:100%' />`,\n        {\n          fragment: true,\n        }\n      );\n      node.properties = {\n        ...node.properties,\n      };\n      node.tagName = \"div\";\n      node.children = canvasHast.children as ElementContent[];\n    }\n  };\n};\n\nasync function getCanvasFromEmbed(path: string): Promise<string> {\n  let canvasMarkdown = \"Loading\";\n  const webcheck = path.trim().toLowerCase();\n\n  if (webcheck.startsWith(\"https://\") || typeof window !== \"undefined\") {\n    await fetch(path)\n      .then((res) => res.text())\n      .then((text) => (canvasMarkdown = text));\n  } else {\n    // To accomodate ssr\n    canvasMarkdown = fs.readFileSync(path, {\n      encoding: \"utf8\",\n      flag: \"r\",\n    });\n  }\n  if (canvasMarkdown === null) return \"\";\n\n  return canvasMarkdown;\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when it’s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n"],"names":["webNamespaces","html","mathml","svg","xlink","xml","xmlns","transform","node","options","transformed","nodeType","space","namespaceURI","fn","s","h","tagName","toLowerCase","content","attributes","getAttributeNames","props","index","length","getAttribute","all","element","type","value","nodeValue","text","comment","children","root","one","afterTransform","nodes","childNodes","child","undefined","push","parser","DOMParser","convert","test","ok","castFactory","Array","isArray","tests","checks","parameters","apply","this","anyFactory","check","checkAsRecord","nodeAsRecord","key","propsFactory","Error","testFunction","parent","Boolean","looksLikeANode","call","empty","EXIT","applyDefaults","config","openEmbededInNewTab","renderMode","canvasBuffer","nodeStrokeWidth","lineStrokeWidth","imagesLoaded","checkImagesLoaded","callback","allLoaded","every","el","complete","console","group","render","jsc","minX","minY","maxX","maxY","_calculateMinimumCanv","Infinity","getNodes","forEach","Math","min","x","y","max","width","height","canvasWidth","canvasHeight","offsetX","offsetY","initRender","log","_extends","version","fill","stroke","viewBox","fillStyle","strokeStyle","color","rect","properties","rx","ry","file","match","image","Promise","resolve","e","reject","drawEmbedded","_temp2","_temp","fetch","then","resp","mdFile","mdast","fromMarkdown","hast","toHast","embed","drawMarkdownEmbed","drawNode","getEdges","edge","fromNode","find","id","toNode","cWidth","cHeight","startX","fromSide","startY","endX","toSide","endY","cp1","cp2","line","d","drawEdge","renderToBuffer","__defProp","Object","defineProperty","__publicField","obj","enumerable","configurable","writable","__defNormalProp","JSONCanvas","constructor","edges","addNode","n","addEdge","getNode","getEdge","removeNode","filter","removeEdge","toString","JSON","stringify","fromString","json","parse","_settle","pact","state","_Pact","bind","v","o","observer","prototype","onFulfilled","result","onRejected","_isSettledPact","thenable","rehypeJsonCanvas","tree","nodesToReplace","testOrVisitor","visitorOrReverse","maybeReverse","reverse","visitor","visit","is","factory","parents","name","subresult","offset","grandparents","toResult","nodeAsParent","concat","visitParents","indexOf","_forOf","canvasPath","src","path","_temp3","canvasMarkdown","webcheck","trim","startsWith","window","res","fs","readFileSync","encoding","flag","getCanvasFromEmbed","canvas","jsonCanvasFromString","canvasHast","fragment","template","document","createElement","innerHTML","parseFragment","parseFromString"],"mappings":"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"}